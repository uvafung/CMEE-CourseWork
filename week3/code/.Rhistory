# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
geom_point(shape = I(3)) +
theme(legend.position = "none")
# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))
# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p
pdf("../results/Girko.pdf", 11.7, 8.3)
print(p)
dev.off()
print("Script completes!")   # print when run with source() to show that script is working
source("Girko.R")
source("Girko.R")
source("Girko.R")
source("Florida_warming.R")
source("Florida_warming.R")
rm(list = ls())
############# Load the dataset ###############
# header = false because the raw data don't have headers
# treat MyData as matrix
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")
############# Inspect the dataset ###############
head(MyData) # shows first few rows of MyData matrix
dim(MyData) # shows dimesions of MyData matrix
str(MyData) # gives list of items in the matrix
fix(MyData) #you can also do this
fix(MyMetaData) # open this in R data editor
############# Transpose ###############
# To get those species into columns and treatments into rows
#This is where header = FALSE comes in. If header is TRUE then only the numbers will be flipped
#but not the column names -- chaos!
MyData <- t(MyData) # transpose (reversing rows and columns).
head(MyData)
fix(MyMetaData) # open this in R data editor
rm(list = ls())
############# Load the dataset ###############
# header = false because the raw data don't have headers
# treat MyData as matrix
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")
############# Inspect the dataset ###############
head(MyData) # shows first few rows of MyData matrix
dim(MyData) # shows dimesions of MyData matrix
############# Transpose ###############
# To get those species into columns and treatments into rows
#This is where header = FALSE comes in. If header is TRUE then only the numbers will be flipped
#but not the column names -- chaos!
MyData <- t(MyData) # transpose (reversing rows and columns).
head(MyData)
dim(MyData)
############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0
head(MyData) # confirm that "space"" is replaced by 0
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #MyData[-1,] = does not include first row, stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data (MyData)
head(TempData)
############# Convert from wide to long format  ###############
#require() returns a logical value -- returns (invisibly) TRUE if the package is available, FALSE if the package is not.
require(reshape2) # load the reshape2 package
?melt #check out the melt function
#melt() convert an object into a molten data frame
#melt() convert a data frame with several measurement columns into a data frame in this canonical format,
#which has one row for every observed (measured) value
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)
print("Script completes!")   # print when run with source() to show that script is working
source("DataWrang.R")
View(MyWrangledData)
rm(list = ls())
############# Load the dataset ###############
# header = false because the raw data don't have headers
# treat MyData as matrix
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")
############# Inspect the dataset ###############
head(MyData) # shows first few rows of MyData matrix
dim(MyData) # shows dimesions of MyData matrix
str(MyData) # gives list of items in the matrix
############# Transpose ###############
# To get those species into columns and treatments into rows
#This is where header = FALSE comes in. If header is TRUE then only the numbers will be flipped
#but not the column names -- chaos!
MyData <- t(MyData) # transpose (reversing rows and columns).
head(MyData)
dim(MyData)
############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0
head(MyData) # confirm that "space"" is replaced by 0
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #MyData[-1,] = does not include first row, stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data (MyData)
head(TempData)
############# Convert from wide to long format  ###############
#require() returns a logical value -- returns (invisibly) TRUE if the package is available, FALSE if the package is not.
require(reshape2) # load the reshape2 package
?melt #check out the melt function
#melt() convert an object into a molten data frame
#melt() convert a data frame with several measurement columns into a data frame in this canonical format,
#which has one row for every observed (measured) value
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)
dim(MyWrangledData)
source("DataWrang.R")
rm(list = ls())
############# Load the dataset ###############
# header = false because the raw data don't have headers
# treat MyData as matrix
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")
############# Inspect the dataset ###############
head(MyData) # shows first few rows of MyData matrix
dim(MyData) # shows dimesions of MyData matrix
str(MyData) # gives list of items in the matrix
fix(MyData) # opens in RStudio Editor
############# Transpose ###############
# To get those species into columns and treatments into rows
#This is where header = FALSE comes in. If header is TRUE then only the numbers will be flipped
#but not the column names -- chaos!
MyData <- t(MyData) # transpose (reversing rows and columns).
head(MyData)
dim(MyData)
############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0
head(MyData) # confirm that "space"" is replaced by 0
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #MyData[-1,] = does not include first row, stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data (MyData)
head(TempData)
############# Convert from wide to long format  ###############
#require() returns a logical value -- returns (invisibly) TRUE if the package is available, FALSE if the package is not.
require(reshape2) # load the reshape2 package
?melt #check out the melt function
#melt() convert an object into a molten data frame
#melt() convert a data frame with several measurement columns into a data frame in this canonical format,
#which has one row for every observed (measured) value
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)
print("Script completes!")   # print when run with source() to show that script is working
source("DataWrang.R")
rm(list = ls())
MyData1 <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE)) # treat MyData1 as matrix
MyMetaData1 <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")
install.packages("tidyverse") #install packages
require(tidyverse)
MyData1 <- tibble::as_tibble(data.frame(t(MyData1), stringsAsFactors = F)) # convert into tibble and transpose it
glimpse(MyData1) # shows first few rows of MyData matrix
view(MyData1)
dim(MyData1) # shows dimesions of MyData matrix
MyData1 <- MyData1 %>%
set_names(slice(.,1)) %>% #set row 1 as column name
slice(-1) #remove row 1 from MyData1
MyWrangledData1 <- pivot_longer(MyData1, cols=5:45, names_to="Species", values_to="Count") # convert to wide format
view(MyWrangledData1)
MyWrangledData1 <- MyWrangledData1 %>%
mutate_all(list(~na_if(.,""))) %>% #replace blank with NA
mutate_all(funs(replace_na(.,0))) # replace NA with 0
view(MyWrangledData1) # check if blank has been replaced with 0
MyWrangledData1 <- MyWrangledData1 %>%
dplyr::mutate_at(1:4, as.factor) # save columns 1:4 as factors
MyWrangledData1$"Count" <- as.integer(MyWrangledData1$"Count") # save Count as integer
str(MyWrangledData1)
glimpse(MyWrangledData1)
view(MyWrangledData1)
dim(MyWrangledData1)
print("Script completes!")   # print when run with source() to show that script is working
source("DataWrangTidy.R")
install.packages("tidyverse")
source("DataWrangTidy.R")
rm(list = ls())
### Read csv
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
### Convert all units from mg into grams
MyDF$Prey.mass.g <- ifelse(grepl("mg", MyDF$Prey.mass.unit), MyDF$Prey.mass * 0.001, MyDF$Prey.mass)
##### Add a column to store the ratio output #####
MyDF <- transform(MyDF, Predator.Prey.Ratio = Prey.mass.g / Predator.mass)
##### Add columns to store the log10 outputs #####
MyDF <- transform(MyDF, Log.Predator.mass = log10(Predator.mass))
MyDF <- transform(MyDF, Log.Prey.mass.g = log10(Prey.mass.g))
MyDF <- transform(MyDF, Log.Predator.Prey.Ratio = log10(Predator.Prey.Ratio))
View(MyDF)
##### Subplots for Predator mass distribution by feeding interaction types #####
pdf("../results/Pred_Subplots.pdf", 11.7, 8.3)
par(mfrow=c(3,2))
par(mfg=c(1,1))
Pred_subplot1 <- hist((MyDF$Log.Predator.mass[MyDF$Type.of.feeding.interaction == "insectivorous"]),
xlab= "log10(Predator Mass (g))", ylab = "Abundance",
main = "Distribution of Insectivorous Predator Mass")
par(mfg=c(2,1))
Pred_subplot2 <- hist((MyDF$Log.Predator.mass[MyDF$Type.of.feeding.interaction == "predacious/piscivorous"]),
xlab= "log10(Predator Mass (g))", ylab = "Abundance",
main = "Distribution of Predacious/Piscivorous Predator Mass")
par(mfg=c(3,1))
Pred_subplot3 <- hist((MyDF$Log.Predator.mass[MyDF$Type.of.feeding.interaction == "piscivorous"]),
xlab= "log10(Predator Mass (g))", ylab = "Abundance",
main = "Distribution of Piscivorous Predator Mass")
par(mfg=c(1,2))
Pred_subplot4 <- hist((MyDF$Log.Predator.mass[MyDF$Type.of.feeding.interaction == "planktivorous"]),
xlab= "log10(Predator Mass (g))", ylab = "Abundance",
main = "Distribution of Planktivorous Predator Mass")
par(mfg=c(2,2))
Pred_subplot5 <- hist((MyDF$Log.Predator.mass[MyDF$Type.of.feeding.interaction == "predacious"]),
xlab= "log10(Predator Mass (g))", ylab = "Abundance",
main = "Distribution of Predacious Predator Mass")
dev.off();
##### Subplots for Prey mass distribution by feeding interaction types #####
pdf("../results/Prey_Subplots.pdf", 11.7, 8.3)
par(mfrow=c(3,2))
par(mfg=c(1,1))
Prey_subplot1 <- hist((MyDF$Log.Prey.mass.g[MyDF$Type.of.feeding.interaction == "insectivorous"]),
xlab= "log10(Prey Mass (g))", ylab = "Abundance",
main = "Distribution of Prey mass in Insectivorous Feeding")
par(mfg=c(2,1))
Prey_subplot2 <- hist((MyDF$Log.Prey.mass.g[MyDF$Type.of.feeding.interaction == "predacious/piscivorous"]),
xlab= "log10(Prey Mass (g))", ylab = "Abundance",
main = "Distribution of Prey mass in Predacious/Piscivorous Feeding")
par(mfg=c(3,1))
Prey_subplot3 <- hist((MyDF$Log.Prey.mass.g[MyDF$Type.of.feeding.interaction == "piscivorous"]),
xlab= "log10(Prey Mass (g))", ylab = "Abundance",
main = "Distribution of Prey mass in Piscivorous Feeding")
par(mfg=c(1,2))
Prey_subplot4 <- hist((MyDF$Log.Prey.mass.g[MyDF$Type.of.feeding.interaction == "planktivorous"]),
xlab= "log10(Prey Mass (g))", ylab = "Abundance",
main = "Distribution of Prey mass in Planktivorous Feeding")
par(mfg=c(2,2))
Prey_subplot5 <- hist((MyDF$Log.Prey.mass.g[MyDF$Type.of.feeding.interaction == "predacious"]),
xlab= "log10(Prey Mass (g))", ylab = "Abundance",
main = "Distribution of Prey mass in Predacious Feeding")
dev.off();
##### Subplots for predator-prey size-ratio distribution by feeding interaction types #####
pdf("../results/SizeRatio_Subplots.pdf", 11.7, 8.3)
par(mfrow=c(3,2))
par(mfg=c(1,1))
Ratio_subplot1 <- hist((MyDF$Log.Predator.Prey.Ratio[MyDF$Type.of.feeding.interaction == "insectivorous"]),
xlab= "Predator-prey size-ratio", ylab = "Abundance",
main = "Distribution of predator-prey size-ratio in Insectivorous Feeding")
par(mfg=c(2,1))
Ratio_subplot2 <- hist((MyDF$Log.Predator.Prey.Ratio[MyDF$Type.of.feeding.interaction == "predacious/piscivorous"]),
xlab= "Predator-prey size-ratio", ylab = "Abundance",
main = "Distribution of predator-prey size-ratio in Predacious/Piscivorous Feeding")
par(mfg=c(3,1))
Ratio_subplot3 <- hist((MyDF$Log.Predator.Prey.Ratio[MyDF$Type.of.feeding.interaction == "piscivorous"]),
xlab= "Predator-prey size-ratio", ylab = "Abundance",
main = "Distribution of predator-prey size-ratio in Piscivorous Feeding")
par(mfg=c(1,2))
Ratio_subplot4 <- hist((MyDF$Log.Predator.Prey.Ratio[MyDF$Type.of.feeding.interaction == "planktivorous"]),
xlab= "Predator-prey size-ratio", ylab = "Abundance",
main = "Distribution of predator-prey size-ratio in Planktivorous Feeding")
par(mfg=c(2,2))
Ratio_subplot5 <- hist((MyDF$Log.Predator.Prey.Ratio[MyDF$Type.of.feeding.interaction == "predacious"]),
xlab= "Predator-prey size-ratio", ylab = "Abundance",
main = "Distribution of predator-prey size-ratio in Predacious Feeding")
dev.off();
###### create new dataframe to store new calculations #####
mean_logpred <- c(tapply(MyDF$Log.Predator.mass, MyDF$Type.of.feeding.interaction, mean)) # calculate mean predator mass by feeding type
mean_logprey <- c(tapply(MyDF$Log.Prey.mass.g, MyDF$Type.of.feeding.interaction, mean)) # calculate mean prey mass by feeding type
median_logpred <- c(tapply(MyDF$Log.Predator.mass, MyDF$Type.of.feeding.interaction, median)) # calculate median predator mass by feeding type
median_logprey <- c(tapply(MyDF$Log.Prey.mass.g, MyDF$Type.of.feeding.interaction, median)) # calculate median prey mass by feeding type
mean_logratio <- c(tapply(MyDF$Log.Predator.Prey.Ratio, MyDF$Type.of.feeding.interaction, mean)) # calculate mean predator-prey size ratio by feeding type
median_logratio <- c(tapply(MyDF$Log.Predator.Prey.Ratio, MyDF$Type.of.feeding.interaction, median)) # calculate median predator-prey size ratio by feeding type, then save as vector
New_Results <- data.frame(mean_logpred, mean_logprey, median_logpred, median_logprey, mean_logratio, median_logratio) #create new dataframe
names(New_Results) <- c("Mean.log10.Predator.Mass", "Mean.log10.Prey.Mass", "Median.log10.Predator.Mass", "Median.log10.Prey.Mass", "Mean.Predator.Prey.Size.Ratio", "Median.Predator.Prey.Size.Ratio")
write.csv(New_Results, "../results/PP_results.csv") #store new dataframe output as csv
print("Script completes!")   # print to show that script is working
source("PP_Dists.R")
rm(list = ls())
a <- read.table("../data/Results.txt", header = TRUE)
head(a)
a$ymin <- rep(0, dim(a)[1]) # append a column of zeros
install.packages("ggplot2")
install.packages("ggplot2")
rm(list = ls())
a <- read.table("../data/Results.txt", header = TRUE)
head(a)
a$ymin <- rep(0, dim(a)[1]) # append a column of zeros
require(ggplot2)
# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
x = x,
ymin = ymin,
ymax = y1,
size = (0.5)
),
colour = "#E69F00",
alpha = 1/2, show.legend = FALSE)
# Print the second linerange
p <- p + geom_linerange(data = a, aes(
x = x,
ymin = ymin,
ymax = y2,
size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)
# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
x = x,
ymin = ymin,
ymax = y3,
size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)
# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))
# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
breaks = seq(3, 5, by = 0.05)) +
scale_y_continuous("My y axis") +
theme_bw() +
theme(legend.position = "none")
pdf("../results/MyBars.pdf", 11.7, 8.3)
print(p)
dev.off()
print("Script completes!")   # print to show that script is working
source("MyBars.R")
source("MyBars.R")
rm(list = ls())
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
rnorm(length(x), mean = 0., sd = 2.5)
# and put them in a dataframe
my_data <- data.frame(x = x, y = y)
# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))
# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
colour = abs(my_lm$residual))
) +
geom_point() +
scale_colour_gradient(low = "black", high = "red") +
theme(legend.position = "none") +
scale_x_continuous(
expression(alpha^2 * pi / beta * sqrt(Theta)))
# add the regression line
p <- p + geom_abline(
intercept = my_lm$coefficients[1][1],
slope = my_lm$coefficients[2][1],
colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
label = "sqrt(alpha) * 2* pi"),
parse = TRUE, size = 6,
colour = "blue")
pdf("../results/MyLinReg.pdf", 11.7, 8.3)
print(p)
dev.off()
print("Script completes!")   # print to show that script is working
source("plotLin.R")
source("plotLin.R")
source("plotLin.R")
source("plotLin.R")
source("PP_Dists.R")
source("MyBars.R")
source("plotLin.R")
rm(list=ls())
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
require(ggplot2)
require(dplyr)
require(tidyr)
require(plyr)
require(broom)
require(purrr)
### Convert all units from mg into grams
MyDF$Prey.mass.g <- ifelse(grepl("mg", MyDF$Prey.mass.unit), MyDF$Prey.mass * 0.001, MyDF$Prey.mass)
### Calculate regression ###
MyDF <- MyDF %>% select("Predator.lifestage","Type.of.feeding.interaction", "Predator.mass", "Prey.mass.g")
NewDF1 <- MyDF %>%  # Regression test 1
unite("Predlifestage.feeding", Predator.lifestage:Type.of.feeding.interaction) %>% # Merge Predator.lifestage and Feeding interaction columns into a new one
group_by(Predlifestage.feeding) %>% # Group data by the new column
do(RegressOutput = tidy(lm(log10(Predator.mass) ~ log10(Prey.mass.g), data = .))) %>% # Regression test that gives slope and intercept
unnest(RegressOutput)
NewDF2 <- MyDF %>% # Regression test 1
unite("Predlifestage.feeding", Predator.lifestage:Type.of.feeding.interaction) %>% # Merge Predator.lifestage and Feeding interaction columns into a new one
group_by(Predlifestage.feeding) %>% # Group data by the new column
do(RegressOutput = glance(lm(log10(Predator.mass) ~ log10(Prey.mass.g), data = .))) %>% # Regression test that gives slope and intercept
unnest(RegressOutput)
### Data transformation ###
EditedDF1 <- select(NewDF1, -c(std.error, statistic, p.value)) # remove irrelevant columns
PivotEditedDF1 <- EditedDF1 %>%
pivot_wider(names_from = term, values_from = estimate)
EditedDF2 <- select(NewDF2, c(Predlifestage.feeding, r.squared, statistic, p.value)) # only retain useful columns
### Rename columns ###
names(PivotEditedDF1)[2] <- "intercept"
names(PivotEditedDF1)[3] <- "slope"
names(EditedDF2)[3] <- "f.statistic"
### Merge the two dataframes together ###
Regress_results <- merge(PivotEditedDF1, EditedDF2, by="Predlifestage.feeding")
View(Regress_results)
### print output ###
write.csv(Regress_results, "../results/PP_Regress_Results.csv") # save as new file in results folder
##### Regression subplots #####
regress_plot1 <- ggplot(MyDF, aes(x = Prey.mass.g, y = Predator.mass, colour = Predator.lifestage)) +
geom_point(shape = 3)
regress_plot2 <- regress_plot1 +
facet_wrap(Type.of.feeding.interaction ~., dir ="v", ncol = 1, strip.position = 'right') +
scale_x_log10("Prey Mass in grams") +
scale_y_log10("Predator mass in grams") +
stat_smooth(method="lm",fullrange=TRUE, se = TRUE, size=.5) +
guides(colour=guide_legend(nrow=1)) +
theme_bw()
regress_plot3 <- regress_plot2 + theme(aspect.ratio = 0.67,
legend.position = "bottom",
legend.box ="horizontal",
plot.margin = unit(c(1,3,1,3), "cm"),
strip.text = element_text(size = 5))
regress_plot3
##### Save figure as a separate pdf file #####
pdf("../results/Regression_subplot.pdf", 11.7, 8.3)
print(regress_plot3)
dev.off()
print("Script completes!")   # print to show that script is working
source("PP_Regress.R")
rm(list=ls())
load ("../data/GPDDFiltered.RData") # load data gpdd
install.packages(c("maps", "mapdata", "rworldmap")) # install useful packages
require(maps)
require(ggplot2)
require(mapdata)
worldmap <- map_data("world") # gives a dataframe of points outlining the world
connect_world <- ggplot() +   # creates a ggplot that join up the points to form polygons
geom_polygon(data = worldmap,
aes(x = long, y = lat, group = group),
fill = NA, colour = "black") +
coord_fixed(1.3)   # fixed map ratio
connect_world # print world map out
dotted_world <- connect_world +
geom_point(data = gpdd, aes(x = long, y = lat), colour = "orange") # print world map with data points
dotted_world
print("Script completes!")   # print to show that script is working
# An analysis based on this data may be biased because most data are collected from North America and Europe.
rm(list=ls())
load ("../data/GPDDFiltered.RData") # load data gpdd
install.packages(c("maps", "mapdata", "rworldmap")) # install useful packages
install.packages(c("maps", "mapdata", "rworldmap"))
require(maps)
require(ggplot2)
require(mapdata)
worldmap <- map_data("world") # gives a dataframe of points outlining the world
connect_world <- ggplot() +   # creates a ggplot that join up the points to form polygons
geom_polygon(data = worldmap,
aes(x = long, y = lat, group = group),
fill = NA, colour = "black") +
coord_fixed(1.3)   # fixed map ratio
connect_world # print world map out
dotted_world <- connect_world +
geom_point(data = gpdd, aes(x = long, y = lat), colour = "orange") # print world map with data points
print(dotted_world)
print("Script completes!")   # print to show that script is working
source("PP_Dists.R")
rm(list=ls())
load ("../data/GPDDFiltered.RData") # load data gpdd
install.packages(c("maps", "mapdata", "rworldmap")) # install useful packages
install.packages(c("maps", "mapdata", "rworldmap"))
require(maps)
require(ggplot2)
require(mapdata)
worldmap <- map_data("world") # gives a dataframe of points outlining the world
connect_world <- ggplot() +   # creates a ggplot that join up the points to form polygons
geom_polygon(data = worldmap,
aes(x = long, y = lat, group = group),
fill = NA, colour = "black") +
coord_fixed(1.3)   # fixed map ratio
connect_world # print world map out
dotted_world <- connect_world +
geom_point(data = gpdd, aes(x = long, y = lat), colour = "orange") # print world map with data points
print(dotted_world)
print("Script completes!")   # print to show that script is working
rm(list=ls())
load ("../data/GPDDFiltered.RData") # load data gpdd
require(maps)
require(ggplot2)
require(mapdata)
worldmap <- map_data("world") # gives a dataframe of points outlining the world
connect_world <- ggplot() +   # creates a ggplot that join up the points to form polygons
geom_polygon(data = worldmap,
aes(x = long, y = lat, group = group),
fill = NA, colour = "black") +
coord_fixed(1.3)   # fixed map ratio
connect_world # print world map out
dotted_world <- connect_world +
geom_point(data = gpdd, aes(x = long, y = lat), colour = "orange") # print world map with data points
print(dotted_world)
print("Script completes!")   # print to show that script is working
